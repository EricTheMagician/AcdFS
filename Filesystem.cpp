//// Created by Eric Yen on 2016-10-05.//#include "Filesystem.h"#include <cstring>#include <errno.h>#include <memory>#include <cstdlib>#include <future>#include "easylogging++.h"#include "Account.h"#include "FileIO.h"#include  <inttypes.h>//#define BOOST_THREAD_PROVIDES_FUTURE//#define BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION//#include <booÆ’st/thread/future.hpp>#include <functional>#include <type_traits>using namespace std;template< class Function, class... Args>std::future<typename std::result_of<Function(Args...)>::type> SFAsync( Function&& f, Args&&... args ){//  http://stackoverflow.com/questions/16296284/workaround-for-blocking-async    typedef typename std::result_of<Function(Args...)>::type R;    auto bound_task = std::bind(std::forward<Function>(f), std::forward<Args>(args)...);    std::packaged_task<R()> task(std::move(bound_task));    auto ret = task.get_future();    std::thread t(std::move(task));    t.detach();    return ret;}vector<future<void>> fsTasks;inline Account* getAccount(fuse_req_t req){    return static_cast<Account *>(fuse_req_userdata(req));}std::shared_ptr<AcdObject> Filesystem::getObjectFromInodeAndReq(fuse_req_t req, ino_t inode){    Account *account = getAccount(req);    auto inodeToObject = account->inodeToObject;    auto cursor = inodeToObject.find(inode);    if(cursor == inodeToObject.cend()){        //object not found        std::shared_ptr<AcdObject> empty;        return empty;    }    return cursor->second;}void Filesystem::forget_multi(fuse_req_t req, size_t count, struct fuse_forget_data *forgets){    fuse_reply_none(req);}void Filesystem::access (fuse_req_t req, fuse_ino_t ino, int mask){    fuse_reply_err(req, 0);};void Filesystem::statfs(fuse_req_t req, fuse_ino_t ino){    struct statvfs stat{            .f_bsize = 65536,            .f_frsize=  65536,            .f_blocks=  1000000,            .f_bfree=  1000000,            .f_bavail=  1000000,            .f_files=  1000000,            .f_ffree=  1000000,            .f_favail=  1000000,            .f_fsid=  1000000,            .f_flag=  0,    };    fuse_reply_statfs(req, &stat);}void Filesystem::create(fuse_req_t req, fuse_ino_t parent_ino, const char *name,        mode_t mode, struct fuse_file_info *fi){    Account *account = getAccount(req);    auto cursor = account->inodeToObject.find(parent_ino);    if(cursor == account->inodeToObject.cend() ){        fuse_reply_err(req, ENOENT);        return;    }    AcdObjectPtr parent = cursor->second;    if(parent){        if(parent->isFile){            fuse_reply_err(req,ENOTDIR);            return;        }    }else{        fuse_reply_err(req,ENOENT);        return;    }    if(parent->m_children == nullptr){        account->getChildrenFromObject(parent);    }    if(parent->m_children->find(name) != parent->m_children->cend() ){        LOG(INFO) << "When creating file with name " << name << " parentId " << parent->m_id << " already existed";        fuse_reply_err(req, EEXIST);        return;    }    LOG(INFO) << "Creating file with name " << name << " and parent Id " << parent;    AcdObjectPtr child = account->createNewChild(parent, name, mode);    FileIO *io = new FileIO(child, fi->flags, account->api);    fi->fh = (uint64_t)io;    struct fuse_entry_param e;    memset(&e, 0, sizeof(struct fuse_entry_param));    e.ino = child->m_stat.st_ino;    e.generation = child->m_generation;    e.attr = child->m_stat;    e.attr_timeout = 100;    e.entry_timeout = 100;    io->open();    fuse_reply_create(req, &e, fi);}void Filesystem::release(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {    FileIO *io = (FileIO *) fi->fh;    Account *account = getAccount(req);    io->release();    if (io->b_needs_uploading) {        SFAsync([account, io] {            io->upload(account);            delete io;        });    } else {        delete io;    }    fuse_reply_err(req, 0);}void Filesystem::read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi) {    //std::async(std::launch::async, [io, &off, &size, &req]() {    FileIO *io = (FileIO *) fi->fh;    auto fileSize = io->m_file->m_stat.st_size;    size = off + size > fileSize ? fileSize - off : size;    SFAsync([=](){        try {            VLOG(7) << "(off,size) = (" << off << ", " << size << ")";            std::string buf = io->read(size, off);            //    LOG(TRACE) << "filesize expected: " << size << ". Received: " << buf.length;            fuse_reply_buf(req, buf.c_str(), buf.length());        }catch(int err){            fuse_reply_err(req, err);        }    });}void Filesystem::open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {    auto account = getAccount(req);    auto cursor = account->inodeToObject.find(ino);    if( cursor == account->inodeToObject.cend()){        fuse_reply_err(req, ENOENT);        return;    }    auto object = cursor->second;    FileIO *io = new FileIO(object, fi->flags, account->api);    fi->fh = (uint64_t) io;    fuse_reply_open(req, fi);}void Filesystem::getattr(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {//    LOG(TRACE) << "getattr";    auto object = getObjectFromInodeAndReq(req, ino);    if(object == nullptr){        fuse_reply_err(req, ENOENT);        return;    }    fuse_reply_attr(req, &(object->m_stat), 180.0);}void Filesystem::lookup(fuse_req_t req, fuse_ino_t parent, const char *name) {    SFAsync([req,parent,name](){//    std::async(std::launch::async, [&req, &parent, name](){        std::string child_name(name);        struct fuse_entry_param e;        auto object = getObjectFromInodeAndReq(req, parent);        if(object == nullptr){            fuse_reply_err(req, ENOENT);            return;        }        auto children = object->m_children;        AcdObjectPtr childptr;        if(children == nullptr){            auto id = object->m_id;            auto account = getAccount(req);            childptr = account->doesParentHaveChild(id, name);            if(childptr == nullptr){                fuse_reply_err(req, ENOENT);                return;            }        }else {            auto cursor = children.get()->find(child_name);            if(cursor == children->cend()){                fuse_reply_err(req, ENOENT);                return;            }            childptr = cursor->second;        }        if(childptr == nullptr){            fuse_reply_err(req, ENOENT);            return;        }        memset(&e, 0, sizeof(e));        e.attr = childptr->m_stat;        e.ino = e.attr.st_ino;        e.attr_timeout = 180.0;        e.entry_timeout = 180.0;        fuse_reply_entry(req, &e);    } );}#define min(x, y) ((x) < (y) ? (x) : (y))static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,                             off_t off, size_t maxsize){    if (off < bufsize)        return fuse_reply_buf(req, buf + off,                              min(bufsize - off, maxsize));    else        return fuse_reply_buf(req, NULL, 0);}void Filesystem::readdir(fuse_req_t req, fuse_ino_t ino, size_t size, off_t off, struct fuse_file_info *fi) {    SFAsync([=](){//    std::future<void> task = std::async(std::launch::async, [&]() {        auto folder = getObjectFromInodeAndReq(req, ino);        if (folder == nullptr) {            fuse_reply_err(req, ENOENT);        }        if (folder->isFile) {            fuse_reply_err(req, ENOTDIR);            return;        }        // load the buffer from the previous call, or create a new buffer        if (folder->m_folder_buffer == nullptr) {            Account *account = getAccount(req);            auto children = account->getChildrenFromObject(folder);            const int totalSize = 256 * children.size();            auto buffer = std::make_shared<std::vector<char>>(totalSize);            size_t accumulated_size = 0;            size_t sz;            for (auto child : children) {                sz = fuse_add_direntry(req, NULL, 0, child->m_name.data(), NULL, 0);                fuse_add_direntry(req, buffer->data() + accumulated_size, totalSize - accumulated_size,                                  child->m_name.data(), &(child->m_stat),                                  accumulated_size + sz);                accumulated_size += sz;            }            buffer->resize(accumulated_size);            folder->m_folder_buffer = buffer;        }        auto buffer = folder->m_folder_buffer.get();        reply_buf_limited(req, buffer->data(), buffer->size(), off, size);    });//    fsTasks.push_back(std::move(task));}void Filesystem::write(fuse_req_t req, fuse_ino_t ino, const char *buf,        size_t size, off_t off, struct fuse_file_info *fi){    SFAsync([=] {        FileIO *io = (FileIO *) fi->fh;        auto *fsize = &(io->m_file->m_stat.st_size);        if (off != *fsize) {            throw ("file not appending to the right place");        } else {            io->b_needs_uploading = true;            io->stream.write(buf, size);            *fsize = *fsize + size;            fuse_reply_write(req, size);        }    });}